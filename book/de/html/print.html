<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The OrbTk Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Orbital Widget Toolkit (OrbTk)is a multi platform toolkit, that enables you to build scalable user interfaces. All components are devoloped with the programming language Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferries.css">
        <link rel="stylesheet" href="theme/2020-edition.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Orbtk Widget Toolkit</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Die Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-orbtk.html"><strong aria-hidden="true">1.2.</strong> Hallo OrbTk!</a></li><li class="chapter-item expanded "><a href="ch01-03-ingredients.html"><strong aria-hidden="true">1.3.</strong> Die Bestandteile</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-workspaces.html"><strong aria-hidden="true">2.</strong> OrbTḱ Die Structur</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-workspace-orbtk.html"><strong aria-hidden="true">2.1.</strong> Workspace: Orbtk</a></li><li class="chapter-item expanded "><a href="ch02-02-workspace-orbtk-core.html"><strong aria-hidden="true">2.2.</strong> Workspace: Orbtk Core</a></li><li class="chapter-item expanded "><a href="ch02-03-workspace-orbtk-client.html"><strong aria-hidden="true">2.3.</strong> Workspace: Orbtk Client</a></li><li class="chapter-item expanded "><a href="ch02-04-workspace-orbtk-tinyskia.html"><strong aria-hidden="true">2.4.</strong> Workspace: Orbtk TinySkia</a></li><li class="chapter-item expanded "><a href="ch02-05-workspace-orbtk-widgets.html"><strong aria-hidden="true">2.5.</strong> Workspace: Orbtk Widgets</a></li><li class="chapter-item expanded "><a href="ch02-06-proc-macros.html"><strong aria-hidden="true">2.6.</strong> Workspace: Process macros</a></li><li class="chapter-item expanded "><a href="ch02-07-utils.html"><strong aria-hidden="true">2.7.</strong> Workspace: Utilities</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-orbtk-examples.html"><strong aria-hidden="true">3.</strong> OrbTk Beispiele</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-widgets.html"><strong aria-hidden="true">3.1.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="ch09-02-showcase.html"><strong aria-hidden="true">3.2.</strong> Showcase</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">4.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">4.1.</strong> A - Schlüsselworte</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">4.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">4.3.</strong> C - Abwerfbare Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-translation.html"><strong aria-hidden="true">4.4.</strong> D - Übersetzungen des Buchs</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The OrbTk Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/redox-os/orbtk-book/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="das-orbital-widget-toolkit"><a class="header" href="#das-orbital-widget-toolkit">Das Orbital Widget Toolkit</a></h1>
<p><a href="img/orbtk_planet.svg"><img src="img/orbtk_planet.svg" width="720"/>
</a></p>
<p><em>von Florian Blasius, mit der Unterstützung der Rust Gemeinschaft</em></p>
<p><em>Kommentierung und Dokumentation durch Ralf Zerres und alle Unterstützer</em></p>
<p>Diese Version des Textes geht davon aus, dass Du OrbTk v0.3.1 oder
nachfolgend in Verbindung mit einer Rust Toolchain v1.41 oder
nachfolgend verwendest. <em>Cargo.toml</em> sollte in den Metadaten
<code>edition=&quot;2018&quot;</code> definieren. Dies ermöglicht die Nutzung von Rust 2018
Edition spezifischen Konstrukten in allen abgeleiteten Projekten.</p>
<p>Vgl. <a href="ch01-01-installation.html">“Installations” Abschnitt in Kapitel 1</a><!-- ignore --></p>
<p>um OrbTk zu installieren oder zu aktualisieren.</p>
<p>The 2020 Edition diese Buchs ist das erste erstelle Release. Es wird
zusammen mit der OrbTk version 0.3.1 veröffentlicht.</p>
<ul>
<li>Appendix A, “Keywords,” erläutert neu eingeführte Bezeichner.</li>
<li>Appendix D ist ein stetig fortschreitender Arbeitsprogress. Neue
Freigaben diese Buches erfolgen nach deren Fertigstellung. Ebenso
wie deren Übersetzung in unterstützte Sprachvarianten.</li>
</ul>
<p>Um dieses Buch online zu lesen wird eine HTML gerenderte Version unter
<a href="https://www.redox-os.org/orbtk-book/book-de/doc/book-de">OrbTk-Book (de)</a> veröffentlicht. Alternativ kann es
auch für die Offline-Nutzung auf lokal installiert werden. Entweder
wird dazu eine gerenderte <code>pdf</code> oder <code>ebook</code> Version heruntergeladen.</p>
<p>Oder das Buch wird aus dem Quellcode erzeugt. Das Rendern erfolgt mit
dem Aufruf von</p>
<pre><code class="language-console">mdbook build --dest-dir doc/book_de
</code></pre>
<!---
Dieser Text wird in [gedrucketer Form und als ebook bei No Starch Press][nsprust] veröffentlicht.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="vorwort"><a class="header" href="#vorwort">Vorwort</a></h1>
<p>Diese Buch spricht alle Rust Entwickler an, die moderne, schnelle und
erweiterbare Benutzeroberflächen erstellen wollen. Da alle Komponenten
von OrbTk in Rust selbst kodiert sind, erbt es alle Vorteile ihrer
herausragenden Infrastruktur. Der minimalistische Ressourcenverbrauch,
die Speichersicherheit und ein komprimierter, gut strukturierter,
modularer Quellcode sind Schlüsselfaktoren, die OrbTk zu einer
vielversprechenden Basis für Deine zukünftigen
Multiplattform-GUI-Projekte machen.</p>
<p>Bereits in den 80er Jahren waren Laufzeitumgebungen wie Java Vorreiter
für die Idee einer “Einmal programmieren, überall laufen
lassen”-Werkzeugkette. Rust in Kombination mit OrbTk bietet die
Möglichkeit, dieses Ziel zu verwirklichen und gleichzeitig
Geschwindigkeit, Sicherheit und Multithreading im Blick zu
behalten. Es steht Dir frei, die Möglichkeiten moderner Hardware zu
nutzen: Reize die Vorteile von Multicore-CPUs in Mikrocomputern,
Einplatinencomputern oder der Vielfalt von Cloud-Infrastrukturen aus.
Mit Rust kannst Du nativen Binärcode kompilieren. OrbTk bietet die
benötigten Crates, um GUIs zu produzieren, die den Anforderungen der
Benutzer entspricht: schnell, sichere, zuverlässig und Plattform
übergreifend!</p>
<p>Du wirst dich an einer freundlichen Community und verständlichen
Texten erfreuen. Du wirst nicht nur Deine Kenntnisse in der
GUI-Entwicklung erweitern, sondern auch Dein Verständnis von Rust-Code
verbessern. Tauchen ein und mache Dich bereit ein Mitglied der OrbTk-
und Rust-Gemeinschaft zu werden!</p>
<p>— Ralf Zerres</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="einführung"><a class="header" href="#einführung">Einführung</a></h1>
<!--
> Hinweis: Diese Ausgabe des Buches ist identisch mit dem [The Orbital Widget Toolkit]
> [nsprust], das in gedruckter Form sowie als E-Book bei [No Starch Press][nsporbtk] erhältlich ist.

[nsporbtk]: https://nostarch.com/orbtk
[nsp]: https://nostarch.com/
-->
<p><a href="img/orbtk.svg"><img src="img/orbtk.svg" width="720"/>
</a></p>
<p>Willkommen zu <em>Das Orbital Widget Toolkit</em>, einem Einführungsbuch über
<code>OrbTk</code>.  Die Programmiersprache Rust hilft Dir, schnellere und
zuverlässige Software zu schreiben. <code>OrbTk</code> bringt die nötigen
Komponenten mit, um moderne grafische Benutzeroberflächen zu
entwickeln. Es bietet eine kohärente Codebasis, die zu nativem
Binärcode kompiliert wird, welcher auf der gewünschten Zielplattform
ausgeführt wird.</p>
<h2 id="merkmale"><a class="header" href="#merkmale">Merkmale</a></h2>
<ul>
<li>Moderne, leichtgewichtige API</li>
<li>Plattformübergreifend</li>
<li>Modulare Komponenten.</li>
<li>Basiert auf der Entity-Component-System-Bibliothek DCES</li>
<li>Flexibles Ereignissystem</li>
<li>Integrierte Widget-Bibliothek</li>
<li>Benutzerdefinierte Widgets</li>
<li>Benutzerdefinierte Theming-Engine</li>
<li>Dynamische Themenumschaltung</li>
<li>Integrierte Debugging-Werkzeuge</li>
<li>Lokalisierung</li>
</ul>
<h2 id="unterstützte-plattformen"><a class="header" href="#unterstützte-plattformen">Unterstützte Plattformen</a></h2>
<ul>
<li>Redox OS (nativ)</li>
<li>Linux (nativ | cargo-node)</li>
<li>macOS (nativ | cargo-node)</li>
<li>Windows (nativ | cargo-node)</li>
<li>openBSD (nicht getestet, sollte aber funktionieren)</li>
<li>Web (cargo-node)</li>
<li>Android (nativ geplant | cargo-node)</li>
<li>iOS (nativ geplant | cargo-node geplant)</li>
<li>Ubuntu Touch (nativ geplant | cargo-node geplant)</li>
</ul>
<h2 id="für-wen-orbtk-gedacht-ist"><a class="header" href="#für-wen-orbtk-gedacht-ist">Für wen OrbTk gedacht ist</a></h2>
<p><code>OrbTk</code> ist ideal für Programmierer, die die Vorteile der
Programmiersprache Rust nutzen wollen. Es besteht keine
Notwendigkeit, Datenstrukturen und Typen zu transformieren: OrbTk
selbst ist in Rust geschrieben. Es übernimmt somit natürlich alle
strukturellen Vorteile der Programmiersprache und stellt die
benötigten GUI Elemente bereit, um Deine grafische Anwendung zu
programmieren. Schauen wir uns ein paar der wichtigsten Gruppen an.</p>
<h3 id="teams-von-entwicklern"><a class="header" href="#teams-von-entwicklern">Teams von Entwicklern</a></h3>
<p>Rust erweist sich als produktives Werkzeug für die Zusammenarbeit in
großen Teams von Entwicklern mit unterschiedlichem Kenntnisstand in
der Systemprogrammierung. Wirf auch einen Blick in das Rust-Buch,
welches die grundlegenden Prinzipien erläutert, und dir hilft besseren
und sicheren Code zu produzieren.</p>
<p><code>OrbTk</code> verwendet die Rust-Toolchain so weit wie möglich wieder.
Zeitgenössische Entwickler, die die Lernkurve durchlaufen haben, werden deren Vorteile nutzen:</p>
<ul>
<li>Cargo, der mitgelieferte Abhängigkeitsmanager und das Build-Tool,
macht das Hinzufügen, Kompilieren und Verwalten von Abhängigkeiten
mühelos und konsistent im gesamten Rust Ökosystem.</li>
<li>Rustfmt sorgt für einen konsistenten Formatierungsstil unter den
Entwicklern.</li>
<li>Der Rust Language Server unterstützt die integrierte
Entwicklungsumgebung (IDE) ihrer Wahl was Integration für
Code-Vervollständigung und Inline-Fehlermeldungen
betrifft. Natürlich vorausgesetzt, dass die IDE ihrer Wahl das LSP
und die Sprache als solches unterstützt.</li>
</ul>
<h3 id="studenten"><a class="header" href="#studenten">Studenten</a></h3>
<p>Rust ist für Studenten und alle, die sich für das Erlernen von
Systemkonzepten interessieren.  Mit Hilfe von Rust haben viele Leute
etwas über Themen wie Betriebssystementwicklung gelernt. Die Community
ist sehr einladend und beantwortet gerne Fragen von Anfängern und
Studierenden. Durch Bemühungen wie dieses Buch, will das Rust-Team
die Systemkonzepte von Rust mehr Menschen zugänglich machen.
Insbesondere solchen, die neu in der Programmierung sind.</p>
<h3 id="unternehmen"><a class="header" href="#unternehmen">Unternehmen</a></h3>
<p>Hunderte von Unternehmen, große und kleine, verwenden Rust produktiv
für eine Vielzahl von Aufgaben. Zu diesen Aufgaben gehören
Kommandozeilen-Tools, Web-Services, DevOps-Tooling, eingebettete
Geräte, Audio- und Videoanalyse und Transkodierung, Kryptowährungen,
Bioinformatik, Suchmaschinen, Anwendungen für das Internet der Dinge,
oder maschinelles Lernen. Sogar große Teile des Firefox-Webbrowsers
sind mittlerweile in Rust neu geschrieben worden.</p>
<h3 id="open-source-entwickler"><a class="header" href="#open-source-entwickler">Open-Source-Entwickler</a></h3>
<p><code>OrbTk</code> ist für Leute, die mit der Programmiersprache Rust, zusammen
mit der Gemeinschaft, ihren Entwickler-Tools und Bibliotheken arbeiten
wollen. Wir würden uns freuen, wenn Du zum Ökosystem mit seinen
Komponenten und Einträgen beitragen könntest. Du bist herzlich
eingeladen.</p>
<h2 id="für-wen-ist-dieses-buch"><a class="header" href="#für-wen-ist-dieses-buch">Für wen ist dieses Buch?</a></h2>
<p>Dieses Buch setzt voraus, dass Du bereits Code in einer anderen
Programmiersprache und anderen GUI-Toolkits geschrieben hast. Es ist
nicht wesentlich, welche Sprache oder welches Toolkit dies war. Wir
haben versucht, das Material so aufzubereiten, dass Personen mit einer
Vielzahl von Entwicklungshintergründen damit arbeiten können. Im
Fokus liegt nicht ein Diskurs was Programmierung <em>ist</em> oder wie man
darüber denkt. Wenn Du völlig neu in der Programmierung bist, wäre
es besser, wenn Du zunächstein Buch zur Hand nimmst, das speziell die
Einführung in die Programmierung zum Thema hat. Auch hier gibt es von der
Rust-Gemeinschaft bereits einige Anstrengungen, wie z.B. [Rust By
Example] https://doc.rust-lang.org/stable/rust-by-example/.</p>
<h2 id="wie-man-dieses-buch-benutzt"><a class="header" href="#wie-man-dieses-buch-benutzt">Wie man dieses Buch benutzt</a></h2>
<p>Im Allgemeinen geht dieses Buch davon aus, dass Du es in der
Reihenfolge von vorne nach hinten liest. Spätere Kapitel bauen auf
Konzepten früherer Kapitel auf, und frühere Kapitel gehen
möglicherweise nicht mehr im Detail auf ein bereits besprochenes
Themas ein; Ist es wesentlich, greifen wir das Thema typischerweise in
einem späteren Kapitel wieder auf.</p>
<p>In diesem Buch finden Sie zwei Arten von Kapiteln: <code>Konzeptkapitel</code> und <code>Projektkapitel</code>.
In Konzeptkapiteln lernst Du einen Aspekt von <code>OrbTk</code> kennen. In
Projektkapiteln werden wir gemeinsam kleine Programme schreiben und
dabei das bisher Gelernte anwenden.</p>
<p>Kapitel 1 erklärt, wie man Rust und OrbTk installiert, wie man ein
minimales Programm schreibt und wie Du <code>cargo</code>, den Paketmanager und
das Build-Tool von Rust, verwendest.</p>
<p>Schließlich enthalten einige Anhänge noch nützliche Informationen über
Rust in einem eher referenzähnlichen Format.</p>
<ul>
<li>Anhang A behandelt die Schlüsselwörter von OrbTk</li>
<li>Anhang B behandelt OrbTks ableitbare Merkmale (traits) und Komponenten (crates).</li>
</ul>
<p>Es gibt keinen falschen Weg, dieses Buch zu lesen: Wenn Du vorwärts
springen willst, nur zu! Du musst vielleicht zu früheren Kapiteln
zurückspringen, wenn ein späteres Kapitel dich verwirrt.
Was immer für Dich funktioniert ist richtig.
<span id="ferris"></span></p>
<p>Ein wichtiger Teil des Lernprozesses von <code>OrbTk</code> ist das Lesen der
Fehlermeldungen, die der Compiler anzeigt: Diese helfen Dir
funktionierenden Code zu erstellen oder diesen zu verbessern. Daher
werden wir auch Beispiele haben, die sich nicht kompilieren lassen.
Zusammen mit der Fehlermeldung, die der Compiler bereitstellt können
dann die Ursachen erklärt und eine funktionierende Lösung erarbeitet
werden.</p>
<p>Beachte bitte, dass Deine Eingaben um ein beliebiges Beispiel
auszuführen, möglicherweise nicht sofort kompiliert! Stelle dann bitte
sicher, dass Du auch den umliegenden Text zum Beispielcode mit
einbeziehst. Ferris hilft sicher auch, den Code zu erkennen, der nicht
funktionsfähig ist:</p>
<table><thead><tr><th>Ferris</th><th>Bedeutung</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td></td></tr>
<tr><td>Dieser Code lässt sich nicht kompilieren!</td><td></td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td></td></tr>
<tr><td>Dieser Code ist panisch und verweigert die Zusammenarbeit!</td><td></td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td></td></tr>
<tr><td>Dieser Quellcode enthält unsicheren Code.</td><td></td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td></td></tr>
<tr><td>Dieser Code erzeugt nicht das gewünschte Verhalten.</td><td></td></tr>
</tbody></table>
<p>In den meisten Situationen führen wir Dich anschliessend zur korrigierten Version des Codes, der dann kompiliert werden kann.</p>
<h2 id="quellcode"><a class="header" href="#quellcode">Quellcode</a></h2>
<p>Die Quelldateien, aus denen dieses Buch generiert wurde, findest Du
auf der Homepage unter <a href="https://github.com/redox-os/orbtk-book/src/de">Orbtk book (de)</a>.</p>
<!-- [orbtk_book_de]: https://www.redox-os.org/orbtk-book/book/de -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="erste-schritte"><a class="header" href="#erste-schritte">Erste Schritte</a></h1>
<p>Beginnen wir mit Deiner OrbTk-Reise! Es gibt viel zu erlernen, fangen wir einfach mal anfangen.
In diesem Kapitel werden wir folgendes erörtern:</p>
<ul>
<li>Die Installation von OrbTk auf Linux, BSD, macOS und Windows.</li>
<li>Das Schreiben einer OrbTk-Anwendung, welche ein Fenster darstellt und in dessen Mitte <code>Hallo OrbTk!</code> erscheint.</li>
<li>Die Benutzung von <code>cargo</code>, Rusts Abhängigkeiten- und Komponentenmanager und auch Build-System.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Der erste Schritt, ist die Installation von Rust. Dies wird im
Folgenden ausführlich beschrieben <a href="https://github.com/rust-lang/book/blob/master/src/ch01-01-installation.md">Rust-Buch Kapitel
1</a></p>
<p>Wenn wir eine OrbTk-Anwendung erstellen, definieren wir die benötigten
Abhängigkeiten zu den OrbTk-Komponenten (crates) in der Datei
Cargo.toml unseres Projekts. Der Kompiliervorgang löst die Referenzen
auf und lädt den Quellcode nach Bedarf herunter.</p>
<blockquote>
<h3 id="kommandozeilen-notation"><a class="header" href="#kommandozeilen-notation">Kommandozeilen-Notation</a></h3>
<p>In diesem Kapitel und im gesamten Buch werden wir einige Befehle
zeigen, die im Terminalfenster erscheinen. Zeilen, die Du in einem
Terminalfenster eingeben solltest, beginnen alle mit <code>$</code>. Du
brauchst das Zeichen “$” nicht einzugeben; es visualisiert einfach
den Beginn jedes Befehls. Zeilen, die nicht mit “$” beginnen,
zeigen normalerweise die Ausgabe des vorherigen Befehls. Außerdem
wird in PowerShell-spezifischen Beispielen “&gt;” anstelle “$”
verwendet.</p>
</blockquote>
<h3 id="fehlersuche"><a class="header" href="#fehlersuche">Fehlersuche</a></h3>
<p>WIP: Auflistung der häufigsten Schuldigen und Bereitstellung einiger grundlegender Lösungen.</p>
<h3 id="lokale-dokumentation"><a class="header" href="#lokale-dokumentation">Lokale Dokumentation</a></h3>
<p>OrbTk bietet die Möglichkeit, die Dokumentation lokal zu installieren,
so dass Sie sie offline lesen können.</p>
<p>Immer, wenn ein Typ, eine Funktion, eine Methode oder eine Komponente
(crate) vom Toolkit referenziert wird und Du Dir nicht sicher bist,
was dieser bzw. diese tut, oder wie er bzw. es zu verwenden ist, werfe
einen Blick auf die Dokumentation der Programmierschnittstelle
(API) um es herauszufinden!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hallo-orbtk"><a class="header" href="#hallo-orbtk">Hallo OrbTk!</a></h2>
<p><a href="img/orbtk.svg"><img src="img/orbtk.svg" width="720"/>
</a></p>
<p>Nachdem du nun die erforderlichen Bausteine installiert hast, lass uns
dein erstes OrbTk Programm schreiben.  Es Tradition mit der
Einarbeitung in eine neue Programmiersprache ein kleines Programm zu
schreiben, das die Worte <code>Hello, world!</code> auf den Bildschirm ausgibt.
Also los. Wir erstellen eine minimale App, die ein Fenster erzeugt und
dieses Fenster an den gegebenen Koordinaten auf dem Bildschirm positioniert.
Das Widget wird unsern Text zentrieren.</p>
<blockquote>
<p>Anmerkung: Diese Buch geht davon aus, dass du Basis-Kenntnisse bei
der Bedienung der Kommandozeile besitzt. Rust selbst hat keine
speziellen Anforderungen, welche Werkzeuge du für das editieren von
Quellcode verwendest und wo du diesen abspeicherst. Wenn du also
bereits mit einer integrierten Entwicklungsumgebung arbeitest (IDE),
nur zu, es spricht nichts dagegen diese auch für OrbTk zu nutzen.
Viele IDEs besitzen mittlerweile ein gewisses Maß an Unterstützung
für die Sprache Rust. Prüfe einfach die vorhandene Dokumentation.
In letzter Zeit hat das Rust Team ein besonderes Augenmerk auf die
Integration von IDE Unterstützung gelegt. Und es wurden große
Fortschritte in dieser Richtung erzielt!</p>
</blockquote>
<h3 id="ein-projekt-verzeichnis-erstellen"><a class="header" href="#ein-projekt-verzeichnis-erstellen">Ein Projekt-Verzeichnis erstellen</a></h3>
<p>Zunächst wird eine Verzeichnis erstellt, in dem wir unseren OrbTk
Quellcode speichern wollen. Es spielt für rust und OrbTk keine große
Rolle, wo sich dieser befindet. Aber für die Beispiele und Übungen in
diesem Buch solltest Du einen Unterordner <em>projects</em> in deinem Home-Verzeichnis
erzeugen. Wir werden im Folgenden immer auf diesen referenzieren.</p>
<p>Öffne ein Terminal und tippe die folgenden Kommandos ein um die gewünschte
Unterordner Struktur <em>projects</em> zu erzeugen:</p>
<p>Für Linux, BSD, macOS und  Power-Shell unter Windows:</p>
<pre><code class="language-console">$ mkdir -p ~/orbtk-book/projects
$ cd ~/orbtk/projects
</code></pre>
<p>In der Windows Shell:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\orbtk-book&quot;
&gt; cd /d &quot;%USERPROFILE%\orbtk-book&quot;
&gt; mkdir projects
&gt; cd projects
</code></pre>
<h3 id="erstellen-und-starten-der-orbtk-applikation"><a class="header" href="#erstellen-und-starten-der-orbtk-applikation">Erstellen und starten der OrbTk Applikation</a></h3>
<p>Im nächsten Schritt erzeugen wir ein neues Projekt und verwenden
hierzu <em>Cargo</em>. Mit einer <em>.toml</em> Datei beschreiben wir die für den
Rust Code erforderlichen Abhängigkeiten und Metadaten. Das stellt
sicher, das auch bei Folgeaufrufen der Kompilier-Prozesses (build) eine
konsistentes Ergebnis erzeugen kann.</p>
<p>Tippe einfach ein:</p>
<pre><code class="language-console">$ cargo new orbtk_hello
$ cd orbtk_hello
</code></pre>
<p>Das erste Kommando, <code>cargo new</code>, verwendet als erstes Argument den Projektnamen.
(”<code>orbtk_hello</code>“). Das zwiete commando wechselt in das neu erstellte Projekt Unterverzeichnis.</p>
<p>Schauen wir uns das erzeugte <em>Cargo.toml</em> mal an:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;orbtk_hello_example&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Listing 1-1: Default Metadaten “orbtk_hello”</span></p>
<p>Mit <code>cargo new</code>, wurde die Projekt Struktur automatisch
erstellt. Vielleicht wurden auch schon die Angaben für Autor und Email angepasst,
wenn <em>Cargo</em> diese Metadaten aus deinen Umgebungsvariablen auslesen konnte.
<em>Cargo</em> hat auch bereits den Quellcode für “Hello, world!” erzeugt.
Lass uns die in der Quelldatei <em>src/main.rs</em> prüfen:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 1-2: Default source file “main.rs”</span></p>
<p>Es gibt keinen Grund, diesen Stand unseres Programmes mit <code>cargo run</code> zu kompilieren,
da wir zunächst noch ein paar Projekt Metadaten zusammen mit ein paar Code Zeilen ergänzen wollen.</p>
<h4 id="aktualisierung-von-cargotoml"><a class="header" href="#aktualisierung-von-cargotoml">Aktualisierung von Cargo.toml</a></h4>
<p>Zuerst öffne bitte die <em>Cargo.toml</em> Datei und gib die Code-Zeilen aus dem Listing 1-1 ein:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml ignore">name = &quot;orbtk_hello&quot;
version = &quot;0.3.1-alpha4&quot;
authors = [
	&quot;Florian Blasius &lt;flovanpt@posteo.de&gt;&quot;,
	&quot;Ralf Zerres &lt;ralf.zerres.de@gmail.com&gt;&quot;,
]
description = &quot;The Orbital Widget Toolkit - Training project&quot;
documentation = &quot;https://docs.rs/orbtk&quot;
repository = &quot;https://github.com/redox-os/orbtk&quot;
readme = &quot;README.md&quot;
license = &quot;MIT&quot;
keywords = [
	&quot;orbital&quot;,
	&quot;widget&quot;,
	&quot;ui&quot;,
]
edition = &quot;2018&quot;

[profile.dev]
opt-level = 1

[dependencies]
orbtk = { git = &quot;https://github.com/redox-os/orbtk.git&quot;, branch = &quot;develop&quot; }
#orbtk = { path = &quot;../../../orbtk&quot;, branch=&quot;next&quot; }

[[bin]]
name = &quot;orbtk_hello&quot;
path = &quot;src/main.rs&quot;
</code></pre>
<p><span class="caption">Listing 1-1: Project metadata “orbtk_hello”</span></p>
<p>Vielleicht wundert es Dich, warum die Eigenschaft <em>name</em> in der <em>Cargo.toml</em> Datei
als <code>hello_orbtk</code> formatiert wurde.</p>
<pre><code class="language-toml ignore">name = &quot;orbtk_hello&quot;
</code></pre>
<p>Es ist eine sinnvolle und empfehlenswerte Gewohnheit, den Rust
Namenkonventionen zu folgen. Ich möchte dich ermutigen, in Rust Code
sogenannte <a href="https://rust-lang.github.io/api-guidelines/naming.html">snake_case</a> Namen zu nutzen. Wenn wir unsere <em>OrbTk</em>
Beispiele erweitern, werden wir den Gruppierungsprefix <code>orbtk</code> weiter
verwenden. Aus diesem Grund verwenden wir für unser erstes kleines
Programm den Namen <code>orbtk_hello</code>.</p>
<h4 id="aktualisierung-von--mainrs"><a class="header" href="#aktualisierung-von--mainrs">Aktualisierung von  main.rs</a></h4>
<p>Der gesamte <em>OrbTk</em> spezifische Quellcode der für die Übersetzung des
ersten Beispeilprogramms “Hello OrbTk!” notwendig ist wird in Listing
1-2 angezeigt. Diesen bitte in die Datei <em>src/main.rs</em> übertragen.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use orbtk::prelude::*;

fn main() {
    // use this only if you want to run it as web application.
    orbtk::initialize();

    Application::new()
        .window(|ctx| {
            Window::new()
                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
                .position((100.0, 100.0))
                .size(420.0, 140.0)
                .child(
                    TextBlock::new()
                        .font_size(28)
                        .h_align(&quot;center&quot;)
                        .text(&quot;Hey OrbTk!&quot;)
                        .v_align(&quot;center&quot;)
                        .build(ctx)
                )
                .build(ctx)
        })
        .run();
}
</code></pre>
<p><span class="caption">Listing 1-2: Quellcode zum erzeugen des Fensters und Ausgabe
von “Hey OrbTk!”</span></p>
<p>Speicher die Datei und gehe zurück in dein Terminal Fenster. Gebe die
folgenden Kommandos ein um das Programm zu Kompilieren und zu starten:</p>
<pre><code class="language-console">$ cargo run --release --example orbtk_hello
</code></pre>
<p>Gleichgültig welches Betriebssystem du gerade verwendest, ein Fenster
sollte sich auf dem Bildschirm öffnen, das dein Text <code>Hey OrbTk!</code>
zentriert in diesem Fenster ausgibt.</p>
<p><a href="img/examples/orbtk_hello.png"><img src="img/examples/orbtk_hello.png" height="150"/>
</a></p>
<p><span class="caption">Image 1-2: Applikations-Fenster mit <code>Hey OrbTk</code></span></p>
<p>Wenn etwas die Fensterausgabe verhindert, schau bitte im Abschnitt</p>
<p><a href="ch01-01-installation.html#troubleshooting">“Troubleshooting”</a> <!-- ignore --> der
Installationsbeschreibung nach, um Hilfestellungen zu erhalten.</p>
<p>Wenn die die gerenderte Ausgaben von <code>Hey OrbTk!</code> deiner App bewundern kannst,
Glückwunsch! Du hast erfolgreich deiner erste OrbTk Anwendung geschrieben.
Das macht Dich zum OrbTk Programmierer — willkommen!</p>
<h3 id="anatomie-einer-orbtk-anwendung"><a class="header" href="#anatomie-einer-orbtk-anwendung">Anatomie einer OrbTk Anwendung</a></h3>
<p>Lass uns die Details ansehen, was gerade mit dem Aufwurf der “Hey
OrbTk!” Anwendung passiert ist. Hier kommt das erste Puzzel-Teilchen:</p>
<pre><code class="language-rust ignore">use orbtk::prelude::*;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>Die erste Zeile fügt die <em>use</em> Anweisung ein. Eine <em>use</em> Anweisung
wird verwendet, um den Pfadname abzukürzen der notwendig ist, um in
Rust einen <em>Modul</em> zu referenzieren. Die Anweisung <em>prelude</em> ist ein
bequemer Weg eine Liste von Dingen zusammenzufassen, die Rust
automatisch in dein Programm importiert.  In unserem Fall haben wir
den Pfad <em>orbtk::prelude</em> eingebunden. Alle Elemente die über diesen
Pfad addressiert werden können (in der Notation mit <em>::</em> beschrieben)
können jetzt als Kurzform über ihren Namen angesprochen werden. Es ist
nicht mehr nötig hierzu den expliziten Pfadname mit zu erfassen (<em>orbtk::prelude::</em>)</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span>fn main() {
<span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>Die dritte Zeile definiert eine Rust Funktion. Der Funktionsname
<code>main</code> ist insoweit besonders, als das immer die Stelle in einem Rust
Programm angibt, mit der die Code-Ausführung beginnt.  In unserem Fall
hat <code>main</code> eine Parameter und liefert auch am Ende der Funktions
nichts zurück. Gäbe es Parameter, sie stünden innerhalb der Klammern, <code>()</code>.</p>
<p>Bitte beachte ebenso, dass die Funktion-Körper (body) in gescheiften
Klammern eingebettet ist, <code>{}</code>. Die Rust Syntax erwartet dies für alle
Funktionsdefinitionen. Im Rust Code-Style ist es üblich, die
Geschweifte Klammer auf der gleichen Zeile wie die
Funktions-Deklaration zu plazieren und dazwischen ein Leerzeichen einzgeben.</p>
<p>Rust bedient sich eines Tools für die automatische Formatierung von
Codezeilen: <code>rustfmt</code>. Es hilt Dir, am Rust Code-Style innerhalb
deiner Projekte konsistent zu bleiben. OrbTk folgt dieser Anleitung.
Abhängig von der Versionsnummer deiner installierten Rust Toolchain
ist die Programmversion von <code>rustfmt</code> vermutlich schon auf deinem System
installiert. Andernfalls prüfe bitte die Online-Dokumentation.</p>
<p>Innerhalb der <code>main</code> Funktion findest die die folgenden Anweisungen:</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // use this only if you want to run it as web application.
    orbtk::initialize();
<span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>Hier gibt es einige wichtige Details herauszustellen.</p>
<ul>
<li>Erstens, Rust code wird standardmäßig mit vier Leerzeichen eingerückt, keine Tabulatoren!</li>
<li>Zweitens, die Methode <code>orbkt::initialize</code> vollzieht alle notwendigen
Schritte, um das OrbTk Umgebung zu initialisieren.</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span>    Application::new()
<span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<ul>
<li>Drittens, die Methode <code>Application::new</code> erstellt eine neue Entität
im verwendeten Entity-Component-System (DECS). DECS ist eine OrbTk
Abhängigkeit die die Erstellung und die Organisation aller innerhalb
von OrbTk verwendeten Entitäten verwaltet. die OrbTk Methoden
verändern die Attribute der Widget Elemente, die entsprechenden DECS
Objekte speichern diese Attribute als Compenenten der gegebenen Entity.</li>
</ul>
<p>Wir werden die OrbTk Makros und Methoden detaillierter in Kapitel
&lt;WIp: chapter&gt; besprechen. Im Moment genügt das Wissen, dass mit dem
Aufruf von <code>::new()</code> die Methode zur Erstellung eines neuen Widgets
angesprochen wird (hier: <code>Application</code>)</p>
<p>Nun zur den nächsten Zeilen:</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span>        .window(|ctx| {
            Window::new()
                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
                .position((100.0, 100.0))
                .size(420.0, 140.0)
<span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>Innerhalb der <code>Application</code> Methode, starten wir weitere
Anweisungen. Das Augenmerk liegt auf folgenden Details:</p>
<ul>
<li>Erstens, das  Rust Stylingsystem rückt den Code um weitere vier Leerzeichen ein. Keine Tabulatoren!</li>
<li>Zweitens, das <code>Pipelining</code> von Code wird über einen Punkt (<code>dot</code>)
eingeleitet, der um den neuen Methodennamen ergänzt wird (Hier:
<code>window</code>).</li>
<li>Drittens, die <code>windows</code> Methode verwendet eine Rust <code>closure</code> als Argument.</li>
</ul>
<p>Wenn du bis jetzt noch nicht mit dem Konzept von <code>closures</code> vertraut
bist, dieser Link ist den Freund:
<a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html">closures</a>.
Diese Referenz bietet ein vertiefendes Verständnis. Im Moment genügt
das Wissen, dass eine closure als effiziente Sprachkomponente an
Stelle einer Funktion genutzt werden kann, Wenn eine closure <code>|ctx| {}</code> ausgeführt wird, wird deren Ergebnis innerhalb der
Rückgabevariable gespeichert (hier: <code>ctx</code>). Die Geschweifte Klammer
definiert den closure Korpus, mit dem Quellcode der innerhalb der closure ausgeführt wird.</p>
<p>Lass und den closure Korpus mal prüfen:</p>
<ul>
<li>Erstens, wir rufen eine Methode auf, um ein neues Fenster als Entität zu erzeugen
(<code>Windows::new</code>).</li>
<li>Zweitens, wir definieren Attribute, die wir dieser Entität anfügen (<code>title</code>,
<code>position</code>, <code>size</code>).</li>
<li>Drittens, innerhalb des neu definierten Fensters erzeugen wir eine neue, hierarchisch untergeordnete Entität
(<code>child</code>).</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span>                .child(
                    TextBlock::new()
                        .font_size(28)
                        .h_align(&quot;center&quot;)
                        .text(&quot;Hey OrbTk!&quot;)
                        .v_align(&quot;center&quot;)
                        .build(ctx)
                )
<span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<ul>
<li>Viertens, dieses <code>child</code> Methode erhält ihrerseits Argumente. Wir
erzeugen eine neue Entität und beschreiben den Widget-Typ
(<code>Textblock::new</code>). Der Textblock wird mit Attributen ergänzt (<code>text</code>,
<code>h_align</code>, <code>v_align</code>). Das Attribut <code>text</code> erhält den gewünschten
Zeichenwert (string). Seine Position wird über Attribute gesteuert,
die für die horizontale und vertikale Ausrichtung zuständig sind
(<code>alignment</code>). Wir wählen <code>center</code> und weisen den später aufzurufenden
Render-Prozess damit an, den Text innerhalb der hierarchisch
übergeordneten Entität (<code>parent</code>) zentriert zu plazieren. In unserem
Fall ist das das Fenster selbst.</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span>                .build(ctx)
<span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>OrbTk versucht von sich aus, die gegebenen Anweisung zeitlich so weit
wie möglich aufzuschieben (lazy handling). Daher rufen wir die
eigentliche Methode für die Erzeugung der Struktur erst am Ende mit
(<code>build(ctx)</code>) auf. Die Entitäten werden instantiert. Der Renderer
wird für die veränderten Komponenten aktiv, berechnet diese neu und
gibt das Ergebnis in den Bildschirmpuffer aus.</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span>        .run();
<span class="boring">}
</span></code></pre>
<p>Mit der letzten Anweisung aktivieren wir die Methode, die den Event
Mechanismus kontrolliert.  Die definierte Applikation wird gestartet,
die beschriebenen Widgets auf den Bildschirm ausgegeben (<code>run</code>).</p>
<p>Rust Codezeilen werden in der Regel mit einem Simikolon abgeschlossen
(<code>;</code>). Dies weist den Kompiler an, das eine gegebene Anweisung
abgeschlossen ist, mit der nächsten fortgefahren werden kann.</p>
<h3 id="kompilierung-und-ausführung-sind-separate-schritte"><a class="header" href="#kompilierung-und-ausführung-sind-separate-schritte">Kompilierung und ausführung sind separate Schritte</a></h3>
<p>Bevor eine OrbTk Application auf der Hardware ablauffähig ist, muss
deren Quellcode über den Kompiler in Maschinencode übersetzt
werden. Ein typisches OrbTk Projekt wird ein ausführbares Programm
(binary) über das Tool <code>cargo</code> erzeugen. <code>cargo</code> legt die erstellte
Datei in den definierten Projekt-Unterordner.</p>
<p>In den Projekt-Metadaten der Toml-Datei können sogenannte Profile
genutze werden, die Kompiler-Optionen für die gewünschte
Ablaufumgebung einstellen (z.B. Optimierungen, Debugging).
Als Unterlassungswerte (defaults) unterstützt <em>cargo</em> die <code>dev</code> und <code>test</code> Profile.
Wird der Aufruf von <em>cargo</em> mit dem <code>--release</code> Argument ergänzt,
kommt das sogenannte release or bench Profil zur Anwendung.</p>
<pre><code class="language-console">$ cargo build --release --bin orbtk_hello.rs
$ ../target/release/hello_orbtk
</code></pre>
<p>Für Windows muss der <code>backslash</code> als Pfad-Trennung verwendet werden:</p>
<pre><code class="language-powershell">&gt; cargo build --release --bin orbtk-hello.rs
&gt; ..\target\release\orbtk_hello.exe
</code></pre>
<p>OrbTk unterstützt Entwickler mit zusätzlichen Informationen zur
Kompile-Umgebung. Hierzu kann der Kompile-Lauf um <code>feature</code> Argumente
ergänzt werden (derzeit: debug, log).</p>
<ul>
<li>debug: die Widgets werden mit Umrandungen gerendert. Dies
erleichtert die Kontrolle der Einhaltung von constraints.</li>
<li>log: Bei Aufruf wird beispeilsweise die Hierarchie der verwendeten
Widgets visualisiert und auf der Kommandozeile ausgegeben.</li>
</ul>
<pre><code class="language-console">$ cargo build --features debug,log --bin hello_orbtk.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="die-bestandteile"><a class="header" href="#die-bestandteile">Die Bestandteile</a></h1>
<blockquote>
<p>WIP: es fehlt eine graphische Repräsentation der Struktur!</p>
</blockquote>
<!-- toc -->
<p><code>OrbTk</code> stellt eine <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">interactive functional reactive</a>
API bereit. Es hängt dabei elementar vom Rust crate <a href="https://docs.rs/dces"><code>DCES</code></a> ab, welches
ein Entity Component System bereitstellt. Die Interaction mit <code>DCES</code> wird vom
<code>Entity Component Manager</code>(ECM) übernommen. Einem Wrapper API, das
<code>OrbTk</code> widgets transparent in <code>ECM</code> Enititäten und  <code>OrbTk</code> Attribute (properties) in
<code>ECM</code> Komponenten (components) übersetzt und verwaltet.
<code>DCES</code> ist wie <code>OrbTk</code> selbst nativ in Rust geschrieben.</p>
<h2 id="gui-elements"><a class="header" href="#gui-elements">GUI Elements</a></h2>
<ul>
<li>Layouts</li>
<li>Events</li>
<li>Behaviors</li>
<li>Messages</li>
</ul>
<h3 id="layouts"><a class="header" href="#layouts">Layouts</a></h3>
<h4 id="warum-brauchen-wir-layouts"><a class="header" href="#warum-brauchen-wir-layouts">Warum brauchen wir Layouts?</a></h4>
<p>Nun, betrachten wir ein eingängiges Beispiel, das in jeder modernen
Applikation umgesetzt werden muss: Mehrere Sprachvarianten sind
erforderlich! Und der Wechsel der gewählten Sprachvariante soll zur
Laufzeit erfolgen. Wir können sicher davon ausgehen, das sich jeder
verwendete Bezeichner für Felder und Beschreibungen in den jeweiligen
Sprachen unterscheidet. Wortlängen und Glyphenbreiten in den Schriften
sind anders. Natürlich ist ebenso die gewählte Schriftart bei der
Berechnung der Größe zu berücksichtigen. Was würde passieren, wenn Du
beispielsweise die Größe einer Entität statisch festlegst? Wir würden
z.B. einen Button mit einer festen Größe kodieren. Wie reagierst Du
nun auf Kontext-Veränderungen von untergeordneten Entitäten (childs)?
Wie gehst Du damit um, dass sich z.B ein Button-Bezeichner, den der Anwender
wahrscheinlich zentriert im Button Rahmen erwartet verändert?</p>
<p>Puh, Du als der Programmierer müsstest an alle möglichen GUI
Darstellungen denken, programmatisch auf jede denkbare
Spracheveränderung reagieren. Ein Alptraum! Nein, wir brauchen einen
tragfähigeren Ansatz.</p>
<h4 id="unsere-lösung"><a class="header" href="#unsere-lösung">Unsere Lösung</a></h4>
<p><code>OrbTk</code> verwendet ein <code>layout</code> System. Dieses System unterstützen die
Möglichkeit, die Größe einer Entität anhand der natürlichen
Dimensionen des Inhalts aufzubereiten. Damit ist es im Toolkit möglich
den gesammten Entitätenbaum im Layout dynamisch anzupassen. Ändert
sich die Applikationslogik und damit die Notwendigkeit einzelne
Entitäten hinzuzufügen, zu verändern oder auszublenden wird dies für
den gesamten Baum in einem dynamischen Layout Prozess umgesetzt. Dabei
werden die individuellen Vorgaben der einzelnen Entitäten
berücksichtigt (<code>constaints</code>).</p>
<p>Die individuellen Vorgaben der Entitäten werden über Eigenschaften
(<code>properties</code>) als Komponenten im <code>DCES</code> gespeichert (<code>components</code>).
Das Konzept folgt einem zwei Phasen Modell. Ein Layout wird daher auch in
zwei Arbeitsschritten verarbeitet:</p>
<ul>
<li><code>Measuring</code> Phase</li>
<li><code>Arrangement</code> Phase</li>
</ul>
<h4 id="measuring"><a class="header" href="#measuring">Measuring</a></h4>
<p>Die <code>Measuring</code> Phase erlaubt uns, die <strong>gewünschte Größe</strong> einer
<code>boxed</code> Entität zu berechnet (<strong>desired size</strong>). Die gewünschte Größe
ist eine Struktur, die die maximalen Werte für Breite und Höhe einer
Entität angibt. Diese Werte werden innerhalb des <code>DCES</code> persistent
gespeichert. Wenn die Verarbeitung eine Wertänderung der gewünschten
Größe feststellt (die gespeicherte und die aktuelle Größe
unterscheiden sich), wird die Kennzeichnung <code>dirty</code> in der Struktur aktualisiert.</p>
<h4 id="arrangement"><a class="header" href="#arrangement">Arrangement</a></h4>
<p>Die Plazierung (<code>Arranging</code>) erfolgt in einem weiteren separaten
Schritt.  Der Vorgang arbeitet den Baum der angesprochenen Elemente in
einer Schleife ab. Dabei verwendet er die <strong>bounds</strong> es jeweiligen
Elements. Ein <strong>bound</strong> beschreibt die finalisierte Position der
Ausrichtung des Elements (Höhe, Breite) und speichert diese im <code>DECS</code>.
Ein Verarbeitungs-Prozess wird nur dann initiiert, wenn ein Element
innerhalb des Baums eine neue Anordnung erzwingt. Alle Elemente werden
nur dann mit den neuen Positionen im Ausgabe-Puffer (<code>render buffer</code>) neu
angeordnet, wenn ihr aktiver Status die als <code>dirty</code> gekennzeichnet ist.</p>
<h4 id="layout-methods"><a class="header" href="#layout-methods">Layout Methods</a></h4>
<p><code>OrbTk</code> unterstützt unterschiedliche Layout Methoden. Dies sind darauf
optimiert, spezifische Anforderungen der unterschiedlichen
Widget-Typen zu berücksichtigen:</p>
<ul>
<li>Absolute</li>
<li>Fixed size</li>
<li>Grid</li>
<li>Padding</li>
<li>Popup</li>
<li>Stack</li>
</ul>
<p>Du findest deren Quellcode im Workspace <code>orbtk_core</code> im Unterverzeichnis <code>layout</code>.
Weitere Informationen zu diesen Methoden werden im <a href="ch02-02-workspace-orbtk-core.html">Kapitel: Orbtk Core</a> besprochen.</p>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<ul>
<li>bottom-up</li>
</ul>
<p>Ein Ereignis wandert bei der Verarbeitung vom Auftreten am Blatt des Enitätenbaums (<code>leaf entity</code>) zum
Stamm (<code>root entity</code>). Also von Unten nach Oben - oder von Aussen nach Innen.</p>
<ul>
<li>top-down</li>
</ul>
<p>Ein Ereignis wandert bei der Verarbeitung vom Auftreten am Stamm
(<code>root entity</code>) zu den Blätter des Enitätenbaums (<code>leaf entity</code>). Also
von Oben nach Unten - oder von Innen nach Außen.</p>
<h3 id="behaviours"><a class="header" href="#behaviours">Behaviours</a></h3>
<p>Es existieren diffenzierte Methoden für die Bearbeitung logisch gruppierter Ereignisse.
Hierzu zählen derzeit die Ereignisklassen</p>
<ul>
<li>Mouse Behaviors</li>
<li>Selection Behaviors</li>
<li>Text Behaviors</li>
</ul>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>Über das Konzept von MessageAdaptern können Nachrichten zwischen beliebigen
Sender- und Empfänger-Widget gesendet und ausgelesen werden. Die
verwendeten Methoden sind <code>thread save</code>.</p>
<p>Jedes Widget kann im State code eine <code>message</code> Methode
definieren. Hier ist der Entwickler frei, welche MessageAdapter
berücksichtigt werden sollen. Die Verarbeitungslogik für ausgelesende
Nachrichten ist somit wahlfrei.</p>
<h2 id="framework-elements"><a class="header" href="#framework-elements">Framework Elements</a></h2>
<p>Alle Elemente des <code>ObtTk</code> Frameworks sind als Sub-Module innerhalb des API organisiert.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="die-orbtk-workspace-struktur"><a class="header" href="#die-orbtk-workspace-struktur">Die OrbTk Workspace Struktur</a></h1>
<p>Der Entwicklungsprozess von OrbTk berücksichtigt folgende definierten
Basis-Prinzipien:</p>
<ul>
<li>Modularität</li>
<li>Erweiterbarkeit</li>
<li>Nativen Multiplattform Support</li>
<li>Minimieurng von Abhängigkeiten</li>
</ul>
<p>Innerhalb des Rust Ecosystems existiert die Funktionalität von
<code>workspaces</code>. Sie sind hilfreiches Instument, ein anwachsendes crate
in sinnvolle kleinere logische Code-Einheiten aufzubrechen.  Neben dem
Ordnungsfaktor helfen <code>workspaces</code> ebenso sich wiederholende zu
reduzieren. Dies gelingt dadurch, dass nur veränderten Code-Blöcken
neu übersetzt werden müssen.</p>
<p>Es ist daher nachvollziehbar, das <code>OrbTk</code> sich dieser Sturktur bedient.
Das Toolkit ist in folgende workspaces unterteilt:</p>
<ul>
<li>orbtk</li>
<li>orbtk_core</li>
<li>orbtk_orbclient</li>
<li>orbtk_tinyskia</li>
<li>orbtk_widgets</li>
<li>proc_macros</li>
<li>utils</li>
</ul>
<p>Diese Komponenten und ihre Relationen zueinander im Toolkit werden in
den folgenden Kapiteln Schritt für Schritt erläutert.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk"><a class="header" href="#workspace-orbtk">Workspace OrbTk</a></h1>
<p>This workspace is the entry point into the framework code.
If you are familiar with Rust code, we are following best practice.</p>
<p>Lets have a quick look at the <code>src</code> sub-directory. As usual you will
find a <code>lib.rs</code> source file.</p>
<p>Obviously here the code starts to define the crates type “lib”. The
next lines define an <code>outer documentation block</code>, which serves as a
short introduction. <code>Outer documentation</code> lines are encoded with two
slashes followed by an exclamation mark (<code>//!</code>).</p>
<p>A very strong feature of the Rust toolchain is the availability of an
inline documentation subsystem. We do use this feature extensively
within <code>OrbTk</code>, to document every public accessible code module,
public functions, structure or enumeration. <code>Inner documentation blocks</code> conventionally start with three slashes (<code>///</code>).</p>
<p>To render the documentation lines, a simple</p>
<pre><code class="language-console">cargo doc
</code></pre>
<p>will generate the online documentation, corresponding to the downloaded release version.
We will timely upload negotiated versions to <a href="https://docs.rs/releases/search?query=orbtk">Docs.rs</a>.</p>
<p>Back to our structure. To keep the code tight and clear, Rust supports
the concept of <strong>modules</strong>. Like in most other higher programming
languages this allows to subdivide your code into related, condense
function blocks. This resolves to increased clarity and
readability. To put the needed modules or crates into scope, take
advantage of the <strong>use</strong> statement.</p>
<p>Both principles helps quite a bit to keep a lean structure beside a
nice developer experience. <code>Ease of use</code> is one main goal, so we
prepare <code>prelude</code> modules, that will take care to present the most
needed peaces accessible in your code. Using short and pregnant
descriptors should be enough to consume the offered <code>OrbTk</code> modules
and functions in your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk_core"><a class="header" href="#workspace-orbtk_core">Workspace orbtk_core</a></h1>
<h2 id="application"><a class="header" href="#application">Application</a></h2>
<p>The <code>application</code> crate provides the base api inside an <code>OrbTk</code> application.
Its elements are consumed via dedicated modules organized in the other sub-crates.</p>
<h3 id="the-contextprovider"><a class="header" href="#the-contextprovider">The ContextProvider</a></h3>
<p>This structure is a temporary solution to share dependencies inside an
<code>OrbTk</code> application. Right now, if the app is started, a new
<code>ContextProvider</code> object is created. The interconnection between
sender and receiver are handled using asynchronous channels with
sender/receiver halves (<code>mpsc</code>).</p>
<ul>
<li>
<p>window_sender
A <code>WindowRequest</code> is used to send the given request to the named window.</p>
</li>
<li>
<p>shell_sender A <code>ShellRequest</code> is used to send the given request to
the application shell. The application shell is aware of the
handled windows. They are differenciated via individual
<code>WindowAdapter</code> objects.</p>
</li>
</ul>
<p>In the given version this module isn’t thread save. It will be
refactored in the next upcoming release.</p>
<h3 id="the-windowadapter"><a class="header" href="#the-windowadapter">The WindowAdapter</a></h3>
<p>Each <code>WindowAdapter</code> handles its unique tree, event pipiline and
shell. They are dynamically stored in the undelying <code>DCES</code> via <strong>ECM</strong>
methods.</p>
<p>The shell will react on UI events. The code for dedicated events are
organized in explicit modules that will trigger their handlers:</p>
<ul>
<li>activation events</li>
<li>clipboard updates</li>
<li>drop events</li>
<li>focus events</li>
<li>key events</li>
<li>mouse events</li>
<li>text input events</li>
<li>window resize events</li>
<li>window scroll events</li>
<li>window system events (like <code>quit</code>)</li>
</ul>
<p>The <code>EventAdapter</code> provides a thread safe way to push events to the
widget tree of a window.</p>
<h3 id="the-overlay-widget"><a class="header" href="#the-overlay-widget">The Overlay widget</a></h3>
<p>The <code>Overlay</code> widget allows the handling of children at the top of the
tree. Thus its children will be presented on top of all other widgets
grouped in the widget-tree.</p>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>A <code>layout</code> is used to dynamically order the children of a
widget. Before we can arrange the components on screen, their sizes,
bounds and constraints have to be <strong>measured</strong>. The ordering process
will result in a parent / child relation (<code>tree</code>), that is represented
and handled in the <strong>ECM</strong>. In a next step, the tree components are
<strong>arranged</strong>. The result is rendered into an output buffer. Last not
least the updated areas are signaled to the output screen.</p>
<p>To measure components, the code will provide suitable defaults for
each property as well as a <code>desired_size</code>. The <code>desired_size</code> will
resolve the <strong>height</strong> and <strong>width</strong> property of the child element.
This values can either be overwritten with an <strong>explicit</strong> component
property inside your rust code, or while referencing to definitions
using a <strong>style</strong> property. Please take into account, that a given
<strong>style</strong> definition will take precedence over all explicitly defined
property elements inside the code. OrbTk will not respect a mixture of
both declarations.</p>
<h3 id="the-absolute-placement"><a class="header" href="#the-absolute-placement">The absolute placement</a></h3>
<p>Only components with a <strong>visibility property</strong> that is labeled with a
<code>Collapsed</code> or <code>Visible</code> option will be taken into account, when
calculating bounds and constraints of a child. The resulting bounds are
points, with absolute x and y positions on the screen (<code>floating point values</code>).</p>
<p>New rendering of the child will only occur, if any of its properties is
marked <code>dirty</code>.</p>
<h3 id="the-fixed-size"><a class="header" href="#the-fixed-size">The fixed size</a></h3>
<p>A <strong>fixed sized</strong> layout is defined by fixed bounds for its
child. Think of images that have to be rendered with a given size, or
a minimum size of a text box.</p>
<h3 id="grid-layout"><a class="header" href="#grid-layout">Grid layout</a></h3>
<p>The <strong>grid layout</strong> is a specialized case of the default alignment
layout. If you declare <strong>rows</strong> and <strong>columns</strong>, the child blocks are
calculated suming up each individual block bounds inside the
corresponding row or column.</p>
<p>You may stretch the blocks to the choosen dimension (<strong>horizontal</strong>
vs. <strong>vertical</strong>). As a result, if you resize the window of the
running app, that grid element will consume the extra size available
because of your interactive change. Vice versa, the elements will
shrink down until the grid child will reach the defined minimum bound.</p>
<h3 id="padding-layout"><a class="header" href="#padding-layout">Padding layout</a></h3>
<p>Padding may be needed, as a property of a broad range of
components. The measurement cycle will calculate the padding value (a
<strong>floating point</strong> value) as a constraint that is added to the space
requirements of the associated content component. You may think of the
<code>padding</code> as a surrounding with a given thickness, that is placed
arround your content.</p>
<p>The following image visualizes the dependencies.</p>
<p><a href="img/layout_constraints.png"><img src="img/layout_constraints.png" width="480"/>
</a></p>
<p><span class="caption">Image 2-2: Layout constraints</span></p>
<h3 id="popup-layout"><a class="header" href="#popup-layout">Popup layout</a></h3>
<p>The <strong>popup layout</strong> is a specialized case of the default alignment
layout. A popup is typically needed to render content, that is related
to a given target widget. That includes the position of the popup
itself, as well as its dynamic created content.</p>
<p>You can find a common use case of a popup if you study the OrbTk code
of a <code>list box</code>.  The list box elements are collected in a stack
widget. The <code>stack</code> itself is placed in a <code>popup</code> widget. And the
popup widget is placed right below the text block that offers a
drop-down selection arrow.</p>
<h3 id="stack-layout"><a class="header" href="#stack-layout">Stack layout</a></h3>
<p>The <strong>stack layout</strong> is a specialized case of the default alignment
layout. A stack offers a use case, where you want to place other
widgets in a congruent <code>horizontal</code> or <code>vertical</code> order.  You may
define a <code>spacing</code> property. This given floating point value is used
as a seperator between each stack member.</p>
<h2 id="localization"><a class="header" href="#localization">Localization</a></h2>
<p>Localization is a research task by itself, if you want to resolve all
syntactic rules that are found when writing prose in different
languages.  OrbTk’s localization crate isn’t ready to resolve all this
complexity, but this may improve in further releases.</p>
<p>Starting with the given implementation, <code>localization</code> can offer methods, that
are able to match and replace text strings. The usage of the <code>localization</code> crate is
optional. If you don’t need any multi lingual adaptions inside your widgets, simply
do not include the <code>localization</code> sugar.</p>
<h3 id="the-building-blocks-of-localization"><a class="header" href="#the-building-blocks-of-localization">The building blocks of localization</a></h3>
<p>If you want to enable the users to select and change the desired display
language of the GUI at runtime, the toolkit needs to match up a requested
text strings (the key) that should be presented inside the view and substitute
it with the corresponding translation string (the target value). Dictionaries
are used to organize the keys as word lists.</p>
<p>OrbTk’s <code>localization</code> implementation has choosen to persitently store
the translation strings inside a <a href="https://github.com/ron-rs/ron"><code>RON</code></a> file. When introducing
the new syntax structure used inside a <code>RON</code> filetype, it was one goal
of the authors to easily match rust types to ron types. That is
exactly the development goal from the RON authors:</p>
<p>“RON is a simple readable data serialization format that looks
similar to Rust syntax. It’s designed to support all of Serde’s data
model, so structs, enums, tuples, arrays, generic maps, and primitive
values.”</p>
<p>You can save each supported language in its individual ron file. The language
files need to be distinctable. A natural way to implement this requirement
is the usage of unique <code>language ids</code>. Most *<em>operating systems</em> take advantage
of a <code>locale subsystem</code>, and save the identification of the active language in
the <code>lang</code> enviroment variable. It’s good practice to include the language id in
the corresponding ron file name.</p>
<p>When you include the <code>localization</code> functionality in your OrbTk code, you
should define constants for each supported <code>language id</code>, that will reference the
ron file in question.</p>
<p>When calling the <code>RonLocalization</code> methods addressing the combination of a language
id and the corresponding dictionary you are able to store the result in <code>language</code>
variable. The crate methods will handle all the heavy lifting to substitute the
source values of the text attributes inside the views with their matching translation
strings in the addressed dictionary.</p>
<h3 id="the-ron-file-structure"><a class="header" href="#the-ron-file-structure">The ron file structure</a></h3>
<p>In OrbTk, the structure <code>RonLocalizationBuilder</code> is defined to take values for
the following parameters</p>
<ul>
<li>language: a String</li>
<li>dictionaries: a HashMap</li>
</ul>
<p>The ron filename representing a language localization should include the language
identifier to ease its distiction from another.</p>
<p>Dictionaries itself are stored
The dictionary is represended by a key value pair</p>
<p>A class <code>Dictionary</code> will include a <code>map</code> named <strong>words</strong>.
The ron type <code>map</code> is like a type <code>struct</code>, but keys are also values instead of
just beenig identifiers.</p>
<ul>
<li>using a ron file</li>
</ul>
<p>Activation of the <code>localization</code> crate inside your source code boils
down to this short example code.</p>
<p>Filename: localization.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static LOCALIZATION_ES_ES: &amp;str = include_str!(&quot;../assets/localization/dictionary_es_ES.ron&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>We do define two language identifiers:</p>
<ul>
<li>_de_de: referencing a ron file with german translation strings</li>
<li>_es_es: referencing a ron file with spanish translation strings</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Application::new()
        .localization(es_es)
<span class="boring">}
</span></code></pre></pre>
<p>When creating the Application block, we do pipe in the localization property.
To keep this example simple, a hardcoded <strong>de_DE</strong> is choosen.
The <a href="https://github.com/redox-os/orbtk/tree/develop/orbtk/examples/showcase.rs"><strong>showcase</strong></a> example inside the orbtk source code
implements a tab widget, that offers a dropdown list, to dynamically change
the active language variant.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let es_es = RonLocalization::create()
        .language(&quot;es_ES&quot;)
        .dictionary(&quot;es_ES&quot;, LOCALIZATION_ES_ES)
        .build();
<span class="boring">}
</span></code></pre></pre>
<p>To compile this example code, go ahead and enter the following comand
in your terminal window:</p>
<pre><code class="language-console">$ cargo run --release orbtk_localization
</code></pre>
<p>Your screen should present an application window showing the translated spanish strings.</p>
<p><a href="img/examples/orbtk_localization.png"><img src="img/examples/orbtk_localization.png" height="150"/>
</a></p>
<p><span class="caption">Image 2-2: Application window with <strong>spanish</strong> localization strings</span></p>
<p>Sure, this code isn’t elegant nor will it suite the real application
demands.  What it does show is the logic, to bind a ron file (storing
the translations of a given language) to a const. When calling
<code>RonLocalization</code>, the <code>text</code> method will resolve text attributes
inside a view or any rust primitive with the translation text resolved
in the language dictionary.</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Every entity that is managed via the provided <strong>ECM</strong> methods (in most cases this will
be widgets) will have associated components. If we are
talking about components inside the toolkit, we name them <code>properties</code>
of a given object.</p>
<h3 id="layout-1"><a class="header" href="#layout-1">Layout</a></h3>
<p>Our aim is a dynamic ordering of objects inside the render
buffer. This ordering needs to respect the specific properties of each
object making up the object tree. All properties declared for the
addressed objects will sum up the constraints that need to be
respected within their layout.</p>
<p>Logical units of properties ease the measurement and assignment
process of the given object tree.</p>
<h4 id="blocks"><a class="header" href="#blocks">Blocks</a></h4>
<p>Inside OrbTk the <code>BlockBuilder</code> method handles a block. A <code>block</code> is a
term that defines an object inside the render surface. A legacy form of
the API was using the idiom <code>row</code> or <code>column</code> to define the position
of a block inside a <code>grid</code> widget. We moved on to use blocks as a
generic term that can be used in all widgets.  Blocks will inherit
default properties:</p>
<ul>
<li>a block size</li>
<li>its minumum size</li>
<li>its maximum size</li>
<li>its current size</li>
</ul>
<p>If we measure a <code>block</code> size, we can choose from an enumeration of valid expressions:</p>
<ul>
<li>Auto: The largest child will be used to measure the block size.</li>
<li>Stretch: The block will be expanded and consume all of the available size.</li>
<li>Size: An explicit floading point value.</li>
</ul>
<h4 id="scrollviewermode"><a class="header" href="#scrollviewermode">ScrollViewerMode</a></h4>
<p>To describe the vertical and horizontal scroll behavior of a widget,
we do make use of the <code>ScrollViewerMode</code>. The ScrollViewerMode will
evaluate a valid enumeration value of the <code>ScrollMode</code>. Per default it
will automatically assign the <strong>Auto</strong> value. That will take care
that the layout logic is able to automatically adjust and manage scroll
movements of associated widget elements (e.g. in ListViews, SelectionViews or TextBoxes).</p>
<p>You may want to handle this scroll movements via your own dedicated
code. Just adapt the mode property <code>horizontal</code> and <code>vertical</code> to your needs and select
<code>ScrollMode::Custom</code>. To completely disable any scrolling logic select
<code>ScrollMode::Disabled</code>.</p>
<h4 id="widget"><a class="header" href="#widget">Widget</a></h4>
<h5 id="focusstate"><a class="header" href="#focusstate">FocusState</a></h5>
<p>To offer natural interactivity with the implemented UI, we should
respect workflow standards. E.g a user is expecting the cursor and the
possibility to change a widget element at the next logical
position. Imagine a form, where the UI offers a layout to enter some
address fields. When you activate such a form, you do expect the
cursor position on the first element of the form. Thus, we need the
concept of a <code>Focus</code> that enable the state logic to preset UI
interaction onto a specified element. The <code>FocusState</code> offers methods
to control the state information of widget elements:</p>
<ul>
<li>Request the focus for an entity.</li>
<li>Remove the focus from an entity.</li>
<li>Reference the current focused entity.</li>
<li>Check the focus state of an entity.</li>
</ul>
<h5 id="keyboardstate"><a class="header" href="#keyboardstate">KeyboardState</a></h5>
<p>The keyboard state tracks which keys are currently pressed. The active
state is stored in a lazy-loaded HashMap.</p>
<p>Beside common key activities, you may need to react on generic
modifier keys (<code>Alt</code>, <code>Ctrl</code>, <code>Hyper</code>, <code>Shift</code>). Helper functions
offer several convenience methods to handle such keyboard events. A
generic method comes in handy, if you don’t care which modifier key is
down (<code>Shift-left</code> or <code>Shift-right</code> =&gt; <code>Shift</code>). The example section
will also tackle the case, where a combined event (<code>Ctrl+S</code>) keyboard
state is handled.</p>
<h2 id="render-objects"><a class="header" href="#render-objects">Render Objects</a></h2>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<h2 id="system"><a class="header" href="#system">System</a></h2>
<h2 id="theming"><a class="header" href="#theming">Theming</a></h2>
<h2 id="tree"><a class="header" href="#tree">Tree</a></h2>
<h2 id="the-widget-base"><a class="header" href="#the-widget-base">The Widget base</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk_client"><a class="header" href="#workspace-orbtk_client">Workspace orbtk_client</a></h1>
<p><code>WIP</code>: The OrbTk GUI client modules</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk_tinyskia"><a class="header" href="#workspace-orbtk_tinyskia">Workspace orbtk_tinyskia</a></h1>
<p><a href="img/orbskia.svg"><img src="img/orbskia.svg" width="720"/>
</a></p>
<p>Rendering is a key component of the toolkit. Everybody is expecting state
of the art presentation of implemented widgets. User interaction that will
result in layout and entity changes inside the GUI should be updated as
soon as possible. A comfortable user experience is mainly influenced by
fast rendering tasks. New rendering of layouts should only take place, if
constraint changes will need to do so. Entities and their attributes will
only require new rendering if a user interaction changes their state
to be dirty.</p>
<p>Lets summarize the main goals of <code>OrbTk</code> rendering infrastructure:</p>
<ul>
<li>
<p>API encapsulated access to all renderer functions</p>
<p>This design decision is taken to keep freedom for further development of
OrbTk when it comes to support different renderers. We are able to support</p>
<ul>
<li>different versions of a given renderer</li>
<li>support different renderer for different target platforms</li>
</ul>
</li>
<li>
<p>2D rendering</p>
<p>We need a fast and complete implementation of all rendering
functions that are supported in the OrbTk toolkit. The following
summary is a list of <code>tiny-skia</code> provided functions:</p>
<ul>
<li>Pixmaps</li>
<li>Canvas</li>
<li>Path</li>
<li>geometry primitives</li>
<li>Blending modes</li>
<li>Path filling</li>
<li>Anti-aliased Path filling</li>
<li>Path stroking</li>
<li>Path hairline stroking</li>
<li>Anti-aliased Path hairline stroking</li>
<li>Stroke dashing</li>
<li>Gradients (linear and radial)</li>
<li>Pixmaps blending (image on image rendering)</li>
<li>Patterns</li>
<li>Fill rect</li>
<li>Stroke rect</li>
<li>Rectangular clipping</li>
<li>Clipping</li>
<li>Anti-aliased clipping</li>
<li>Analytical anti-aliased Path filling</li>
<li>Dithering</li>
<li>Blending modes</li>
</ul>
</li>
</ul>
<p>We are looking forward to a Rust native ecosystem that handles <code>text rendering</code>. This is a complex task and by the time of writing a
complete library addressing this issue isn’t available.
The Rust community has developed building blocks, like</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
a Font parser: ttf-parser.</li>
<li><input disabled="" type="checkbox" checked=""/>
a Text shaper: rustybuzz or all-sorts.</li>
<li><input disabled="" type="checkbox" checked=""/>
a Font database: fontdb (supporting a font fallback mechanism).</li>
</ul>
<p>The missing peace, beside the glue code to use the components inside
orbtk_tinyskia is a high-quality <code>glyph rasterization library</code>. Preferably it will offer a <code>FreeType</code> level of
quality. <code>ab_glyph_rasterizer</code> or <code>fontdue</code> might evolve to fill this
gap.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk_widgets"><a class="header" href="#workspace-orbtk_widgets">Workspace orbtk_widgets</a></h1>
<p>As a UI developer consuming OrbTk, you most probably will get in
touch with the <code>widget</code> sub-crate. If you get comfortable with the
terminology of <code>views</code> and their <code>states</code>, it’s quite easy to
implement even complex structures. The GUI components are declarative
and you will code them inside the <code>view</code> blocks. All callbacks that
will handle the functional processing are coded inside the <code>state</code>
blocks. User input (e.g. mouse events, keyboard input) as well as
event handler generated feedback is handled and processed from methods
of the associated <code>state</code> blocks.</p>
<p>The <code>behavior modules</code> are separated to handle specialized cases. If
an event is emitted that belongs to a behavior class, the associated
action is handled by a behavior method. In particular you will
recognize modules for the following behaviors:</p>
<ul>
<li>focus</li>
<li>mouse</li>
<li>selection</li>
<li>text</li>
</ul>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<p>When you create a <code>view</code> block inside an OrbTk application, it is
required to insert definitions that declare what elements are going to
be present inside the user interface.</p>
<h3 id="what-is-a-view"><a class="header" href="#what-is-a-view">What is a View</a></h3>
<p>If you take the Rust code that makes a <code>view</code> in a structural way, it
will answer to the following questions:</p>
<ul>
<li>Which entities are used?</li>
<li>What is the entities tree formed?</li>
<li>What attributes are coupled with the given entity?</li>
<li>What handlers should take care when a given event is emitted?</li>
</ul>
<h3 id="what-is-the-code-structure-of-a-view"><a class="header" href="#what-is-the-code-structure-of-a-view">What is the code structure of a View</a></h3>
<p>First, the inside the source code that takes your <code>view</code> needs to call
the <code>widget!</code> macro. This macro automatically implements the <code>Widget</code>
trait. When instantiated, it will inherit all default properties from
a base widget, which gets you started with consistent preset values.</p>
<p>The syntax of this macro call will require you to select</p>
<ul>
<li>the desired <code>view-name</code> (e.g: “NavigationView”)</li>
<li>optional: the name of the associated <code>state-structure</code> (e.g:
“<NavigationState>“)</li>
</ul>
<p>If you like to assign property names inside the view, go ahead and
introduce an extensible list of the property-variables. Each variable
will take a name and define its associated type.</p>
<p>In a next step you enhance the <code>Template</code> trait with an implementation
of your new widget. You are required to code a function called
<code>template</code>.  The syntax of this function will take the following
arguments</p>
<ul>
<li><code>self</code>, the implementation of your view-name</li>
<li>the <code>Id</code> of the entity</li>
<li>the <code>Context</code>, as a mutual reference to the BuildContext</li>
</ul>
<p>All the widget structures you are going to use inside of <code>template</code>
will be coded as child’s of <code>self</code>.</p>
<h2 id="states"><a class="header" href="#states">States</a></h2>
<p>When you create a <code>state</code> block inside an OrbTk application, it is
required to define the structures you want to work on in the <code>State</code>
implementation.</p>
<h3 id="what-is-a-state"><a class="header" href="#what-is-a-state">What is a State</a></h3>
<p>The Rust code that makes a <code>state</code> is associated to the <code>view</code> block
of your widget. Go and ask yourself:</p>
<ul>
<li>What actions should be processed on a given event?</li>
<li>How should we handle user input?</li>
<li>What happens if an entity attribute is changed and gets dirty?</li>
</ul>
<p>From a procedural point of view, states will provide methods that are
processed depending of the event status inside the a widget.</p>
<pre class="mermaid">graph TD;
	State--&gt;init;
	State--&gt;update;
	State--&gt;cleanup;
	update--&gt;message;
	message--&gt;layout;
	layout--&gt;update_post_layout;

</pre>
<p><span class="caption">Workflow 1-1: State handling methods</span></p>
<h3 id="what-is-the-structure-of-a-state"><a class="header" href="#what-is-the-structure-of-a-state">What is the structure of a State</a></h3>
<p>First, inside the source code that takes your <code>state</code>, you will go and
declare its structure name. This name corresponds to the parameter
value you chose inside the <code>widget!</code> macro call of your widgets
view (e.g “NavigationState”).</p>
<p>In a next step you enhance the <code>State</code> trait with an implementation of
your state structure. Most probable, you create and adapt the
following functions:</p>
<h4 id="the-cleanup-function"><a class="header" href="#the-cleanup-function">The <code>cleanup</code> function</a></h4>
<p>This function is called as a destructor, when a widget is removed or
your application terminates.</p>
<h4 id="the-init-function"><a class="header" href="#the-init-function">The <code>init</code> function</a></h4>
<p>This function is called to initialize the widget state. You can preset
attributes <strong>before</strong> the view is activated and presented to the user.</p>
<h4 id="the-message-function"><a class="header" href="#the-message-function">The <code>message</code> function</a></h4>
<p>The <code>message subsystem</code> is offering methods to chain events, that can
be interchanged and accessed from any defined <code>state</code>. You will code a
<code>message</code> function to take advantage of this functionality.</p>
<p>The syntax of this function will take the following arguments</p>
<ul>
<li><code>self</code>, the implementation of your message function</li>
<li>the mutable <code>messages</code> variable, referencing the MessageReader</li>
<li>the <code>Context</code>, as a mutual reference to the BuildContext</li>
</ul>
<p>As already explained, you should define an action enumeration, (e.g
“NavigationAction”), that will code the values that are possible or
desired (e.g “SaveSettings”, “LoadSettings”). Inside the <code>message</code>
function you will loop through the <code>messages</code> and match the action
values you are interested in.</p>
<h4 id="the-update-function"><a class="header" href="#the-update-function">The <code>update</code> function</a></h4>
<p>Whenever the attribute of an entity is changed, OrbTk will render it
dirty. The <code>update</code> function is taking care to react on any triggered
dirty state. You will probably define an <code>Action</code> enumeration that
will name and list all action states you are interested in. Now, if
you match an <code>action</code> in the <code>update</code> function, you can react on this
with all the Rust syntax flexibility.</p>
<h4 id="the-update_post_layout-function"><a class="header" href="#the-update_post_layout-function">The <code>update_post_layout</code> function</a></h4>
<p>OrbTk will run this function <strong>after</strong> the rendering crate has
processed the new layout for your view.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-proc_macros"><a class="header" href="#workspace-proc_macros">Workspace proc_macros</a></h1>
<p><code>WIP</code>: Precedural macros</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-utilities"><a class="header" href="#workspace-utilities">Workspace utilities</a></h1>
<p><code>WIP</code>: OrbTk helper utilities</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-example-applications"><a class="header" href="#orbtk-example-applications">OrbTk Example Applications</a></h1>
<p>This is WIP</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-example-widgets"><a class="header" href="#orbtk-example-widgets">OrbTk Example Widgets</a></h1>
<p>This is WIP</p>
<p>Please document the example application widgets.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-example-showcase"><a class="header" href="#orbtk-example-showcase">OrbTk Example Showcase</a></h1>
<p>This is WIP</p>
<p>Please document the example application showcase.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-appendix"><a class="header" href="#orbtk-appendix">OrbTk Appendix</a></h1>
<p>In Arbeit...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-appendix---keywords"><a class="header" href="#orbtk-appendix---keywords">OrbTk Appendix - Keywords</a></h1>
<p>This is WIP</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-appendix---operators"><a class="header" href="#orbtk-appendix---operators">OrbTk Appendix - Operators</a></h1>
<p>In Arbeit...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-appendix---ableitbare-eigenschaften-traits"><a class="header" href="#orbtk-appendix---ableitbare-eigenschaften-traits">OrbTk Appendix - Ableitbare Eigenschaften (traits)</a></h1>
<p>In Arbeit...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-d-translations-of-the-book"><a class="header" href="#appendix-d-translations-of-the-book">Appendix D: Translations of the Book</a></h1>
<p>For resources in languages other than English. This is work in progress; see
<a href="https://github.com/redox-os/orbtk-book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">the Translations label</a> to help or let us know about a new translation!</p>
<ul>
<li><a href="https://github.com/redox-os/orbtk">Deutsch</a></li>
<li><a href="https://github.com/redox-os/orbtk">Français</a></li>
</ul>
<!---
- [Deutsch](https://github.com/redox-os/orbtk/book-de)
- [Français](https://github.com/redox-os/orbtk/book-fr)
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferries.js"></script>
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
